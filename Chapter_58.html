<!DOCTYPE HTML>
<html lang="zh-TW" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> 測試 - Easy Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong>  更新</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong>  介紹</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong>  我是誰？</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong>  簡單英語學 Rust</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong>  Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong>  🚧 和 ⚠️</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong>  註解</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong>  型別</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong>  型別推導</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong>  列印 hello, world!</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong>  顯示和除錯</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong>  可變性</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong>  堆疊、堆積和指標</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong>  更多關於列印</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong>  字串</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong>  const 和 static</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong>  更多關於參考</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong>  可變參考</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong>  傳遞參考給函式</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong>  複製型別</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong>  集合型別</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong>  向量</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong>  元組</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong>  控制流程</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong>  結構體</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong>  列舉</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong>  迴圈</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong>  實作結構體和列舉</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong>  解構</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong>  參考和點運算子</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong>  泛型</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong>  Option 和 Result</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong>  其他集合型別</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong>  問號(?)運算子</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong>  特徵</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong>  鏈結方法</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong>  疊代器</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong>  閉包</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong>  dbg! 巨集和 .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong>  &str 的種類</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong>  生命週期</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong>  內部可變性</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong>  Cow</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong>  類型別名</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong>  todo! 巨集</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong>  Rc</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong>  多執行緒</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong>  函式中的閉包</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong>  impl 特徵</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong>  Arc</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong>  通道</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong>  閱讀 Rust 文件</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong>  屬性</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong>  Box</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong>  Box 包裹的特徵</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong>  Default 和生成器模式</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong>  Deref 和 DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong>  Crates 和模組</a></li><li class="chapter-item expanded "><a href="Chapter_58.html" class="active"><strong aria-hidden="true">59.</strong>  測試</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong>  外部 crates</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong>  標準函式庫之旅</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong>  撰寫巨集</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong>  cargo</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong>  接受使用者輸入</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong>  使用檔案</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong>  cargo doc 命令</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong>  結束了嗎？</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dieterplex/easy_rust_cht" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/dieterplex/easy_rust_cht/edit/main/README.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="測試"><a class="header" href="#測試">測試</a></h2>
<p>在我們瞭解模組後，測試正是現在學習的好主題。在 Rust 中測試你的程式碼是非常容易的，因為你可以立刻在你的程式碼旁寫測試。</p>
<p>開始測試最簡單的方法就是在函式上面加上 <code>#[test]</code>。這裡是個簡單的範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn two_is_two() {
    assert_eq!(2, 2);
}
<span class="boring">}</span></code></pre></pre>
<p>但如果你試圖在 Playground 中執行它，它會給出錯誤：<code>error[E0601]: `main` function not found in crate `playground</code>。這是因為你不使用 <em>Run</em> 來進行測試，你要使用的是 <em>Test</em>。另外，你不使用 <code>main()</code> 函式進行測試 - 它們在外面執行。要在 Playground 中執行這個，點選 <em>RUN</em> 旁邊的 <code>···</code>，然後把它改為 <em>Test</em>。現在如果你點選它，它將會跑測試。(如果你已經安裝了 Rust，你將輸入 <code>cargo test</code> 來做測試)</p>
<p>這裡是輸出內容：</p>
<pre><code class="language-text">running 1 test
test two_is_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>讓我們把 <code>assert_eq!(2, 2)</code> 改成 <code>assert_eq!(2, 3)</code>，看看會有什麼結果。當測試失敗時，你會得到更多的資訊：</p>
<pre><code class="language-text">running 1 test
test two_is_two ... FAILED

failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>assert_eq!(left, right)</code> 是 Rust 中測試函式的主要方法。如果它不成功，它將會顯示值的不同：左邊有 2，但右邊有 3。</p>
<p><code>RUST_BACKTRACE=1</code> 是什麼意思？這是電腦上的設定，可以提供更多關於錯誤的資訊。幸好 Playground 也有：點選 <code>STABLE</code> 旁邊的 <code>···</code>，然後設定 Backtrace 為 <code>ENABLED</code>。如果你這樣做，它會給你 <em>很多</em> 的資訊：</p>
<pre><code class="language-text">running 1 test
test two_is_two ... FAILED

failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: 2 == 3', src/lib.rs:3:5
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/libunwind.rs:86
   1: backtrace::backtrace::trace_unsynchronized
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:78
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:59
   4: core::fmt::write
             at src/libcore/fmt/mod.rs:1076
   5: std::io::Write::write_fmt
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/io/mod.rs:1537
   6: std::io::impls::&lt;impl std::io::Write for alloc::boxed::Box&lt;W&gt;&gt;::write_fmt
             at src/libstd/io/impls.rs:176
   7: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:62
   8: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:49
   9: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:198
  10: std::panicking::default_hook
             at src/libstd/panicking.rs:215
  11: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:486
  12: std::panicking::begin_panic
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:410
  13: playground::two_is_two
             at src/lib.rs:3
  14: playground::two_is_two::{{closure}}
             at src/lib.rs:2
  15: core::ops::function::FnOnce::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libcore/ops/function.rs:232
  16: &lt;alloc::boxed::Box&lt;F&gt; as core::ops::function::FnOnce&lt;A&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/liballoc/boxed.rs:1076
  17: &lt;std::panic::AssertUnwindSafe&lt;F&gt; as core::ops::function::FnOnce&lt;()&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:318
  18: std::panicking::try::do_call
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:297
  19: std::panicking::try
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:274
  20: std::panic::catch_unwind
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:394
  21: test::run_test_in_process
             at src/libtest/lib.rs:541
  22: test::run_test::run_test_inner::{{closure}}
             at src/libtest/lib.rs:450
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>除非你真的找不到問題所在，否則你不需要使用回溯(Backtrace)。但幸運的是你也不需要全部理解。如果你繼續閱讀，你最終會看到第 13 行，那裡寫著 <code>playground</code>──那是它提到的你的程式碼的位置。其它的一切都是關於 Rust 為了執行你的程式,在其他函式庫中所做的事情。但是這兩行告訴你，它看的是 playground 的第 2 行和第 3 行，這是個要檢查那裡的提示。這裡重複那個部分：</p>
<pre><code class="language-text">  13: playground::two_is_two
             at src/lib.rs:3
  14: playground::two_is_two::{{closure}}
             at src/lib.rs:2
</code></pre>
<p>編輯：Rust 在 2021 年初改進了它的回溯訊息，只顯示最有意義的資訊。現在更容易閱讀了：</p>
<pre><code class="language-text">failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:493:5
   1: core::panicking::panic_fmt
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:92:14
   2: playground::two_is_two
             at ./src/lib.rs:3:5
   3: playground::two_is_two::{{closure}}
             at ./src/lib.rs:2:1
   4: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
   5: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s
</code></pre>
<p>現在讓我們再把回溯關閉，回到常規的測試。現在我們將會寫一些其他函式，並使用測試函式來測試它們。這裡有幾個範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
#[test]
fn it_returns_two() {
    assert_eq!(return_two(), 2);
}

fn return_six() -&gt; i8 {
    4 + return_two()
}
#[test]
fn it_returns_six() {
    assert_eq!(return_six(), 6)
}
<span class="boring">}</span></code></pre></pre>
<p>現在都能執行成功：</p>
<pre><code class="language-text">running 2 tests
test it_returns_two ... ok
test it_returns_six ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>這不是太難。</p>
<p>通常你會想把你的測試放在它們自己的模組中。要做到這一點，需要使用相同的 <code>mod</code> 關鍵字，並在它前面加上 <code>#[cfg(test)]</code>(記住：<code>cfg</code> 的意思是&quot;組態&quot;)。你還想要繼續在每一個測試前面寫 <code>#[test]</code>。這是因為以後當你安裝 Rust 時，你可以做更復雜的測試。你將可以執行一個測試、全部測試、或者其中一些測試。另外別忘了要寫 <code>use super::*;</code>，因為測試模組需要使用它上層的函式。現在它看起來會像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
fn return_six() -&gt; i8 {
    4 + return_two()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_returns_six() {
        assert_eq!(return_six(), 6)
    }
    #[test]
    fn it_returns_two() {
        assert_eq!(return_two(), 2);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="測試驅動開發"><a class="header" href="#測試驅動開發">測試驅動開發</a></h3>
<p>在閱讀 Rust 或其他語言時，你可能會看到&quot;測試驅動開發(Test-driven development)&quot;這個詞。這是編寫程式的一種方式，有些人喜歡它，而有些人則喜歡其他的方式。&quot;測試驅動開發&quot;的意思是&quot;先寫測試，再寫程式碼&quot;。當你這樣做的時候，你將會有很多測試程式碼給所有你想要你的程式碼去做的事情。然後你才開始寫程式碼，並執行測試來看你是否做對了。接著當你加入和重寫你的程式碼時，測試程式碼會一直在那裡告訴你是否有什麼東西出了問題。這在 Rust 中相當容易，因為編譯器給出了很多關於待修復內容的資訊。讓我們寫個測試驅動開發的小範例，來看看它像什麼樣子。</p>
<p>讓我們想像可以接受使用者輸入的計算機。它可以加 (+)，也可以減 (-)。如果使用者寫 &quot;5 + 6&quot;，它應該回傳 11，如果使用者寫 &quot;5 + 6 - 7&quot;，它應該回傳 4，以此類推。所以我們將先從測試函式開始。你也可以看到，測試中的函式名通常都相當長。這是因為你可能會執行很多的測試，並且你想瞭解哪些測試失敗了。</p>
<p>我們將想像有個名為 <code>math()</code> 的單獨函式會做完所有工作。它將回傳 <code>i32</code>(我們將不會使用浮點數)。因為它需要回傳一些東西，我們每次都將只會回傳 <code>6</code>。然後我們將寫三個測試函式。當然它們都會失敗。現在的程式碼像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn math(input: &amp;str) -&gt; i32 {
    6
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>它給我們這些資訊：</p>
<pre><code class="language-text">running 3 tests
test tests::one_minus_minus_one_is_two ... FAILED
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>以及關於 <code>thread 'tests::one_plus_one_is_two' panicked at 'assertion failed: `(left == right)` </code> 的所有資訊。我們不需要在這裡全部印出來。</p>
<p>現在來思考如何做出計算機。我們將接受任何數字，以及 <code>+-</code> 符號。我們將允許空格，但不允許其他任何東西。所以讓我們從帶有 <code>const</code> 並包含以上所有字元的字串開始。然後我們將使用 <code>.chars()</code> 按字元進行疊代，並使用 <code>.all()</code> 確保它們都在裡面。</p>
<p>然後，我們將新增一個會恐慌的測試。要做到這一點，要加上 <code>#[should_panic]</code> 屬性：現在如果它恐慌了測試就會成功。</p>
<p>現在程式碼看起來像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;; // 別忘記結尾的空白

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }
    6 // 現在我們仍然還是回傳 6
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }

    #[test]
    #[should_panic]  // 這裡是我們的新測試 - 它應該要恐慌
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>現在當我們執行測試時，我們得到這樣的結果：</p>
<pre><code class="language-text">running 4 tests
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_minus_minus_one_is_two ... FAILED
test tests::panics_when_characters_not_right ... ok
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>有一個成功了！我們的 <code>math()</code> 函式現在只能接受設定好的輸入了。</p>
<p>下一步是編寫實際的計算機。這就是先有測試的有趣之處：實際的程式碼要晚很多才開始出現。首先我們將把計算機的邏輯放在一起。我們要做到以下幾點：</p>
<ul>
<li>所有的空白都應該被移除。這很容易用 <code>.filter()</code> 實作。</li>
<li>所有輸入容應該變成 <code>Vec</code> 中的元素。<code>+</code> 不需要成為輸入，但是當程式看到 <code>+</code> 時，應該知道數字已經完成處理了。例如，輸入 <code>11+1</code> 應該像這樣做：1) 看到 <code>1</code>，把它推到一個空字串中。1) 看到另一個 1，把它推到字串中(現在是 &quot;11&quot;)。3) 看到 <code>+</code>，知道數字已經結束，把字串推到向量裡，然後清空字串。</li>
<li>程式必須計算出 <code>-</code> 的數量。奇數(1、3、5...)表示減法，偶數(2、4、6...)表示加法。所以 &quot;1--9&quot; 應該是 10，而不是 -8。</li>
<li>程式應該移除最後一個數字後面的任何東西。<code>5+5+++++----</code> 都是由出現在 <code>OKAY_CHARACTERS</code> 中的所有字元組成，但它應該清理變成 <code>5+5</code>。這很容易用 <code>.trim_end_matches()</code> 做到，它能讓你把符合 <code>&amp;str</code> 結尾的東西都去掉。</li>
</ul>
<blockquote>
<p>順便說一下，<code>.trim_end_matches()</code> 和 <code>.trim_start_matches()</code> 曾經是 <code>trim_right_matches()</code> 和 <code>trim_left_matches()</code>。但後來人們注意到有些語言是從右到左(波斯語、希伯來語等)，所以左右都是錯的。你可能還能在一些程式碼中看到舊名字，但它們是一樣的。</p>
</blockquote>
<p>首先我們只想通過所有的測試。通過測試後，我們就可以&quot;重構(Refactor)&quot;了。重構的意思是讓程式碼變得更好，通常是透過像結構體、列舉和方法等方式。這裡是我們使測試通過的程式碼：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric())
    {
        panic!(&quot;Please only input numbers, +-, or spaces.&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;(); // 移除結尾的 + 和 -, 和全部空白
    let mut result_vec = vec![]; // Results 放在這裡
    let mut push_string = String::new(); // 這是我們每次推送資料的字串. 我們將會在迴圈裡持續重複使用它.
    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !push_string.is_empty() { // 如果字串是空的, 我們不想把 &quot;&quot; 推到 result_vec 裡
                    result_vec.push(push_string.clone()); // 但如果不是空的, 它就會是數字. 把它推到向量裡
                    push_string.clear(); // 接著清除字串
                }
            },
            '-' =&gt; { // 如果我們得到的是 -,
                if push_string.contains('-') || push_string.is_empty() { // 檢查看看是否為空或有 -
                    push_string.push(character) // 如果是如此, 那麼把它推到字串裡
                } else { // 不然, 它將會包含數字
                result_vec.push(push_string.clone()); // 那麼把數字推到 result_vec 裡, 清除字串後再把 - 推進去
                push_string.clear();
                push_string.push(character);
                }
            },
            number =&gt; { // number 在這裡的意思是 &quot;其它任何匹配到的東西&quot;. 也是我們所選擇的名字
                if push_string.contains('-') { // 我們可能有一些 - 字元要先推進去
                    result_vec.push(push_string.clone());
                    push_string.clear();
                    push_string.push(number);
                } else { // 但如果沒有, 那就表示我們可以把數字推進去
                    push_string.push(number);
                }
            },
        }
    }
    result_vec.push(push_string); // 迴圈結束後把字串推進去. 沒有 .clone() 的必要因為我們不會再使用它了

    let mut total = 0; // 現在是時候算數學了. 從總合開始
    let mut adds = true; // true = 加法, false = 減法
    let mut math_iter = result_vec.into_iter();
    while let Some(entry) = math_iter.next() { // 疊代元素過去
        if entry.contains('-') { // 如果有 - 字元, 檢查奇數或偶數
            if entry.chars().count() % 2 == 1 {
                adds = match adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue; // 繼續處理下一個元素
            } else {
                continue;
            }
        }
        if adds == true {
            total += entry.parse::&lt;i32&gt;().unwrap(); // 如果沒有 '-', 肯定是數字. 那我們解包很安全
        } else {
            total -= entry.parse::&lt;i32&gt;().unwrap();
            adds = true;  // 減完後, 重設 adds 為 true.
        }
    }
    total // 終於要回傳總合
}
   /// 我們將多加上一些測試來確認行為

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0); // 這是新測試
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8); // 這是新測試
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>現在測試都通過了！</p>
<pre><code class="language-text">running 6 tests
test tests::one_minus_minus_one_is_two ... ok
test tests::nine_plus_nine_minus_nine_minus_nine_is_zero ... ok
test tests::one_minus_two_is_minus_one ... ok
test tests::eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end ... ok
test tests::one_plus_one_is_two ... ok
test tests::panics_when_characters_not_right ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>你可以看到，在測試驅動的開發中有來回的過程。它是像這樣的：</p>
<ul>
<li>首先你要寫出所有你能想得到的測試。</li>
<li>然後你開始寫程式碼。</li>
<li>當你寫程式碼的時候，你會得到其他測試的想法。</li>
<li>你新增測試，你的測試隨著你的進展而成長。你有的測試越多，你的程式碼被檢查的次數就越多。</li>
</ul>
<p>當然測試並不能檢查所有的東西，認為&quot;通過所有測試 = 完美的程式碼&quot;是錯誤的。但是測試對於修改程式碼是很棒的。如果你以後修改了程式碼並執行測試，如果其中有一個測試不成功，你就會知道什麼該修復。</p>
<p>現在我們可以重寫（重構）一點程式碼。一個好方式是用 Clippy 開始。如果你安裝了 Rust，那麼你可以輸入 <code>cargo clippy</code>。如果你使用的是 Playground，那麼點選 <code>TOOLS</code>，選擇 Clippy。Clippy 會檢閱你的程式碼，並給出能讓你的程式碼更精簡的提示。我們的程式碼沒有任何錯誤，但它能更好。</p>
<p>Clippy 告訴我們兩件事：</p>
<pre><code class="language-text">warning: this loop could be written as a `for` loop
  --&gt; src/lib.rs:44:5
   |
44 |     while let Some(entry) = math_iter.next() { // Iter through the items
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for entry in math_iter`
   |
   = note: `#[warn(clippy::while_let_on_iterator)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#while_let_on_iterator

warning: equality checks against true are unnecessary
  --&gt; src/lib.rs:53:12
   |
53 |         if adds == true {
   |            ^^^^^^^^^^^^ help: try simplifying it as shown: `adds`
   |
   = note: `#[warn(clippy::bool_comparison)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison
</code></pre>
<p>這是真的：<code>for entry in math_iter</code> 比 <code>while let Some(entry) = math_iter.next()</code> 簡單得多。而 <code>for</code> 迴圈實際上是個疊代器，所以我們沒有任何理由要寫 <code>.iter()</code>。謝謝 clippy！而且我們也不需要做 <code>math_iter</code>：我們可以只要寫 <code>for entry in result_vec</code>。</p>
<p>現在我們將開始做些真正的重構。我們將建立 <code>Calculator</code> 結構體，而不是單獨的變數。這將擁有我們使用的所有變數。我們將改變兩個名字來讓它更清楚。<code>result_vec</code> 將變成 <code>results</code>，<code>push_string</code> 將變成 <code>current_input</code>(currenㄙㄨ的意思是 &quot;現在&quot;)。而到目前為止，它只有一種方法：new。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>現在我們的程式碼實際上更長了一點，但也更容易讀懂。比如 <code>if adds</code> 現在是 <code>if calculator.adds</code>，這就跟讀英文完全一樣。看起來像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}

const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.current_input.push(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.current_input.clear();
                calculator.current_input.push(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                    calculator.current_input.push(number);
                } else {
                    calculator.current_input.push(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>最後我們增加兩個新方法。一個叫做 <code>.clear()</code>，清除 <code>current_input()</code>。另一個叫做 <code>push_char()</code>，把輸入推到 <code>current_input()</code> 上。這裡是我們重構後的程式碼：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }

    fn clear(&amp;mut self) {
        self.current_input.clear();
    }

    fn push_char(&amp;mut self, character: char) {
        self.current_input.push(character);
    }
}

const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.push_char(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.clear();
                calculator.push_char(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                    calculator.push_char(number);
                } else {
                    calculator.push_char(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>現在大概已經夠好了。我們可以寫更多的方法，但是很多行像是 <code>calculator.results.push(calculator.current_input.clone());</code> 已經很清楚了。重構的時機最好是在你的程式碼完成後還能輕鬆閱讀的時候。你不希望只是為了讓程式碼變短而重構：例如，<code>clc.clr()</code> 就比 <code>calculator.clear()</code> 差很多。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Chapter_57.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="Chapter_59.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Chapter_57.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="Chapter_59.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>

<!DOCTYPE HTML>
<html lang="zh-TW" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> 特徵 - Easy Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong>  更新</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong>  介紹</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong>  我是誰？</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong>  簡單英語學 Rust</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong>  Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong>  🚧 和 ⚠️</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong>  註解</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong>  型別</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong>  型別推導</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong>  列印 hello, world!</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong>  顯示和除錯</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong>  可變性</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong>  堆疊、堆積和指標</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong>  更多關於列印</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong>  字串</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong>  const 和 static</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong>  更多關於參考</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong>  可變參考</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong>  傳遞參考給函式</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong>  複製型別</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong>  集合型別</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong>  向量</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong>  元組</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong>  控制流程</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong>  結構體</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong>  列舉</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong>  迴圈</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong>  實作結構體和列舉</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong>  解構</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong>  參考和點運算子</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong>  泛型</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong>  Option 和 Result</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong>  其他集合型別</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong>  問號(?)運算子</a></li><li class="chapter-item expanded "><a href="Chapter_34.html" class="active"><strong aria-hidden="true">35.</strong>  特徵</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong>  鏈結方法</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong>  疊代器</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong>  閉包</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong>  dbg! 巨集和 .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong>  &str 的種類</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong>  生命週期</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong>  內部可變性</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong>  Cow</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong>  類型別名</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong>  todo! 巨集</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong>  Rc</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong>  多執行緒</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong>  函式中的閉包</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong>  impl 特徵</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong>  Arc</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong>  通道</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong>  閱讀 Rust 文件</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong>  屬性</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong>  Box</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong>  Box 包裹的特徵</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong>  Default 和生成器模式</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong>  Deref 和 DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong>  Crates 和模組</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong>  測試</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong>  外部 crates</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong>  標準函式庫之旅</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong>  撰寫巨集</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong>  cargo</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong>  接受使用者輸入</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong>  使用檔案</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong>  cargo doc 命令</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong>  結束了嗎？</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dieterplex/easy_rust_cht" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/dieterplex/easy_rust_cht/edit/main/README.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="特徵"><a class="header" href="#特徵">特徵</a></h2>
<p>我們以前見過特徵(Trait)：<code>Debug</code>、<code>Copy</code>、<code>Clone</code> 都是特徵。要賦予型別特徵，就必須實作它。因為 <code>Debug</code> 和其他的特徵都很常見，所以我們有可以自動實作的屬性(attribute)。那就是當你寫下 <code>#[derive(Debug)]</code> 時所發生的事情：你自動實作了 <code>Debug</code>。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MyStruct {
    number: usize,
}

fn main() {}</code></pre></pre>
<p>但是其他的特徵就比較困難了，所以需要用 <code>impl</code> 手動實作。例如，<code>Add</code> (在 <code>std::ops::Add</code> 找到) 是用來累加兩個東西的。但是 Rust 並不知道你到底要怎麼累加，所以你必須告訴它。</p>
<pre><pre class="playground"><code class="language-rust">struct ThingsToAdd {
    first_thing: u32,
    second_thing: f32,
}

fn main() {}</code></pre></pre>
<p>我們可以累加 <code>first_thing</code> 和 <code>second_thing</code>，但我們需要提供更多資訊。也許我們想要 <code>f32</code>，所以像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let result = self.second_thing + self.first_thing as f32
<span class="boring">}</span></code></pre></pre>
<p>但也許我們想要整數，所以像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let result = self.second_thing as u32 + self.first_thing
<span class="boring">}</span></code></pre></pre>
<p>或者我們只是想把 <code>self.first_thing</code> 放在 <code>self.second_thing</code> 旁邊這樣加起來。所以如果我們把 55 加到 33.4，我們想看到的是 5533.4，而不是 88.4。</p>
<p>所以首先讓我們看一下如何做出特徵。<code>trait</code> 要記得的重點在於它們的行為 (behaviour)。要實作特徵時，寫下 <code>trait</code>，然後建立一些函式。</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // 簡單結構體 - Animal只有名字
    name: String,
}

trait Dog { // 狗的特徵給出一些功能性
    fn bark(&amp;self) { // 牠會吠叫
        println!(&quot;Woof woof!&quot;);
    }
    fn run(&amp;self) { // 並且牠會跑
        println!(&quot;The dog is running!&quot;);
    }
}

impl Dog for Animal {} // 現在Animal有了特徵Dog

fn main() {
    let rover = Animal {
        name: &quot;Rover&quot;.to_string(),
    };

    rover.bark(); // Animal能用 bark()
    rover.run();  // 並且牠能用 run()
}</code></pre></pre>
<p>這範例沒問題，但是我們不想印出 &quot;The dog is running&quot;。如果你想的話，你可以更改 <code>trait</code> 給你的方法，但你必須有相同的簽名。這意味著它需要接受同樣的東西，並回傳同樣的東西。例如，我們可以改變 <code>.run()</code> 方法，但我們必須遵循簽名。簽名是：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
fn run(&amp;self) {
    println!(&quot;The dog is running!&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p><code>fn run(&amp;self)</code> 的意思是 &quot;fn <code>run()</code> 接受 <code>&amp;self</code> 引數，且不回傳任何內容&quot;。所以你不能這樣做：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(&amp;self) -&gt; i32 { // ⚠️
    5
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 會說：</p>
<pre><code class="language-text">   = note: expected fn pointer `fn(&amp;Animal)`
              found fn pointer `fn(&amp;Animal) -&gt; i32`
</code></pre>
<p>但我們可以做這樣做：</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // 簡單結構體 - Animal只有名字
    name: String,
}

trait Dog { // 狗的特徵給出一些功能性
    fn bark(&amp;self) { // 牠會吠叫
        println!(&quot;Woof woof!&quot;);
    }
    fn run(&amp;self) { // 並且牠會跑
        println!(&quot;The dog is running!&quot;);
    }
}

impl Dog for Animal {
    fn run(&amp;self) {
        println!(&quot;{} is running!&quot;, self.name);
    }
}

fn main() {
    let rover = Animal {
        name: &quot;Rover&quot;.to_string(),
    };

    rover.bark(); // Animal能用 bark()
    rover.run();  // 並且牠能用 run()
}</code></pre></pre>
<p>現在印出了 <code>Rover is running!</code>。這樣可以是因為我們回傳的是 <code>()</code>，也就是什麼都沒有，也是特徵簽名所說的。</p>
<p>當你在寫特徵時，你可以只寫函式簽名，但如果你這樣做，使用者將必須寫出函式的實作內容。讓我們來試試。現在我們把 <code>bark()</code> 和 <code>run()</code> 改成只有 <code>fn bark(&amp;self);</code> 和 <code>fn run(&amp;self);</code>。這不是完整的函式，所以必須由使用者來寫。</p>
<pre><pre class="playground"><code class="language-rust">struct Animal {
    name: String,
}

trait Dog {
    fn bark(&amp;self); // bark() 說要有 &amp;self 並且不回傳
    fn run(&amp;self); // run() 說要有 &amp;self 並且不回傳。
                   // 那麼現在我們必須要自己寫出它們。
}

impl Dog for Animal {
    fn bark(&amp;self) {
        println!(&quot;{}, stop barking!!&quot;, self.name);
    }
    fn run(&amp;self) {
        println!(&quot;{} is running!&quot;, self.name);
    }
}

fn main() {
    let rover = Animal {
        name: &quot;Rover&quot;.to_string(),
    };

    rover.bark();
    rover.run();
}</code></pre></pre>
<p>所以當你建立特徵時，你必須思考：&quot;我應該寫哪些函式？而使用者又應該寫哪些函式？&quot;如果你認為使用者每次使用某個函式的方式應該一致，那麼就該把它寫出來。如果你認為使用者會有不同的使用方式，那就只寫出函式簽名即可。</p>
<p>那讓我們嘗試為我們的結構體實作 Display 特徵。首先我們將做個簡單的結構體：</p>
<pre><pre class="playground"><code class="language-rust">struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };
}</code></pre></pre>
<p>現在我們想要印出 <code>mr_mantle</code>。Debug 很容易推導出：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };

    println!(&quot;Mr. Mantle is a {:?}&quot;, mr_mantle);
}</code></pre></pre>
<p>但 Debug 列印不是最漂亮的印出方式，因為它看起來像這樣。</p>
<pre><code class="language-text">Mr. Mantle is a Cat { name: &quot;Reggie Mantle&quot;, age: 4 }
</code></pre>
<p>因此如果我們想要印出得更好看，就需要為 <code>Cat</code> 實作 <code>Display</code>。在 <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">https://doc.rust-lang.org/std/fmt/trait.Display.html</a> 上我們可以看到 Display 的資訊，還有一個範例。它說：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.longitude, self.latitude)
    }
}

fn main() {}</code></pre></pre>
<p>有些部分我們還不明白，比如 <code>&lt;'_&gt;</code> 和 <code>f</code> 是做什麼的。但我們知道 <code>Position</code> 結構體：它只是兩個 <code>f32</code>。我們也懂 <code>self.longitude</code> 和 <code>self.latitude</code> 是結構體中的欄位。所以，也許我們可以拿這個程式碼來給我們的結構體用在 <code>self.name</code>和<code>self.age</code> 上。另外 <code>write!</code> 看起來很像 <code>println!</code>，所以會感到很熟悉。所以我們寫成這樣：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} is a cat who is {} years old.&quot;, self.name, self.age)
    }
}

fn main() {}</code></pre></pre>
<p>讓我們新增 <code>fn main()</code>。現在我們的程式碼像這樣：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
      write!(f, &quot;{} is a cat who is {} years old.&quot;, self.name, self.age)
  }
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };

    println!(&quot;{}&quot;, mr_mantle);
}</code></pre></pre>
<p>成功了! 現在當我們使用 <code>{}</code> 列印時，我們得到 <code>Reggie Mantle is a cat who is 4 years old.</code>。這看起來好多了。</p>
<p>順帶一提，如果你實現了 <code>Display</code>，那麼你就可以免費得到 <code>ToString</code> 特徵。這是因為你使用 <code>format!</code> 巨集時間接使用了 <code>.fmt()</code> 函式，它讓你可以用 <code>.to_string()</code> 來做出 <code>String</code>。所以我們可以做類似這個範例做的事情，我們把 <code>reggie_mantle</code> 傳給想要 <code>String</code> 的函式，或者其他任何東西。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} is a cat who is {} years old.&quot;, self.name, self.age)
    }
}

fn print_cats(pet: String) {
    println!(&quot;{}&quot;, pet);
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };

    print_cats(mr_mantle.to_string()); // 這裡把牠轉換為 String
    println!(&quot;Mr. Mantle's String is {} letters long.&quot;, mr_mantle.to_string().chars().count()); // 把牠轉換成字元計數
}</code></pre></pre>
<p>印出：</p>
<pre><code class="language-text">Reggie Mantle is a cat who is 4 years old.
Mr. Mantle's String is 42 letters long.
</code></pre>
<p>關於特徵要記得的是，它們與某些東西的行為有關。你的 <code>struct</code> 是如何動作的？它能做什麼？這就是特徵的作用。如果你想想我們到目前為止所看到的一些特徵，它們全都是關於行為的：<code>Copy</code> 是型別可以做的事情。<code>Display</code> 也是型別能做的事情。<code>ToString</code> 是另一個特徵，它也是型別可以做的事情：它可以改變型別成為 <code>String</code>。在我們的 <code>Dog</code> 特徵中，<em>Dog</em> 這個詞並不意味著你能做的事情，但它給出了一些讓它做某些事情的方法。你也可以為 <code>struct Poodle</code> 或 <code>struct Beagle</code> 實作它，它們都會得到 <code>Dog</code> 的方法。</p>
<p>讓我們再看另一個更純粹是行為的範例。我們將想像一個有一些簡單角色的幻想遊戲。一個是 <code>Monster</code>，另外兩個是<code>Wizard</code> 和 <code>Ranger</code>。<code>Monster</code> 只是有 <code>health</code>，所以我們可以攻擊它，其他兩個還沒有任何東西。但是我們做了兩個特徵。一個叫 <code>FightClose</code>，讓你近身作戰。另一個是 <code>FightFromDistance</code>，讓你在遠處戰鬥。只有 <code>Ranger</code> 可以使用 <code>FightFromDistance</code>。它會像是這裡看到的這樣：</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

struct Wizard {}
struct Ranger {}

trait FightClose {
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            &quot;You attack with your sword. Your opponent now has {} health left.&quot;,
            opponent.health
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            &quot;You attack with your hand. Your opponent now has {} health left.&quot;,
            opponent.health
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance {
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                &quot;You attack with your bow. Your opponent now has {} health left.&quot;,
                opponent.health
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            &quot;You attack with your rock. Your opponent now has {} health left.&quot;,
            opponent.health
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard {};
    let aragorn = Ranger {};

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}</code></pre></pre>
<p>印出：</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left.
You attack with your bow. Your opponent now has 20 health left.
</code></pre>
<p>我們總是在特徵裡傳入 <code>self</code>，但是我們現在還不能用它做什麼。那是因為 Rust 不知道什麼型別會使用它。它可能是一個 <code>Wizard</code>，也可能是一個 <code>Ranger</code>，也可能是一個叫做 <code>Toefocfgetobjtnode</code> 的新結構體，或者其他任何東西。為了讓 <code>self</code> 具有一定的功能，我們可以在特徵中加入必要的特徵。比如說，如果我們想用 <code>{:?}</code> 列印，那麼我們就需要 <code>Debug</code>。你只要把它寫在 <code>:</code>(冒號)後面，就可以把它加入到特徵中。現在我們的程式碼像這樣：</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

#[derive(Debug)] // 現在 Wizard 有 Debug
struct Wizard {
    health: i32, // 現在 Wizard 有 health
}
#[derive(Debug)] // Ranger 也是
struct Ranger {
    health: i32, // Ranger 也是
}

trait FightClose: std::fmt::Debug { // 現在型別需要有 Debug 來使用 FightClose
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            &quot;You attack with your sword. Your opponent now has {} health left. You are now at: {:?}&quot;, // 我們現在可以用 {:?} 印出 self 因為我們有 Debug
            opponent.health, &amp;self
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            &quot;You attack with your hand. Your opponent now has {} health left.  You are now at: {:?}&quot;,
            opponent.health, &amp;self
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance: std::fmt::Debug { // 我們也可以加上特徵 FightFromDistance : FightClose, 因為 FightClose 需要 Debug
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                &quot;You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}&quot;,
                opponent.health, self
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            &quot;You attack with your rock. Your opponent now has {} health left.  You are now at: {:?}&quot;,
            opponent.health, self
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}</code></pre></pre>
<p>現在印出：</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
</code></pre>
<p>在真實的遊戲中，為每個型別重寫印出內容可能比較好，因為 <code>You are now at: Wizard { health: 60 }</code> 看起來有點可笑。這也是為什麼特徵裡面的方法通常很簡單，因為你不知道什麼型別會使用它。例如，你不能寫出 <code>self.0 += 10</code> 這樣的東西。但是這個範例表明，我們可以在我們正在撰寫的特徵裡面使用其他的特徵。當我們這樣做的時候，我們會得到一些我們可以使用的方法。</p>
<p>另外一種使用特徵的方式是使用所謂的 <code>特徵界限 (trait bound)</code>。意思是&quot;透過特徵進行限制&quot;。特徵限制很簡單，因為特徵實際上不需要任何方法，或者說根本不需要任何東西。讓我們用類似但不同的東西重寫我們的程式碼。這次我們的特徵沒有任何方法，但我們有限定要使用的特徵的其它函式。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;  // 所以我們現在不用再每次寫 std::fmt::Debug

struct Monster {
    health: i32,
}

#[derive(Debug)]
struct Wizard {
    health: i32,
}
#[derive(Debug)]
struct Ranger {
    health: i32,
}

trait Magic{} // 這些特徵都沒有方法，它們只是特徵界限
trait FightClose {}
trait FightFromDistance {}

impl FightClose for Ranger{} // 每個型別都得到 FightClose,
impl FightClose for Wizard {}
impl FightFromDistance for Ranger{} // 但只有 Ranger 得到 FightFromDistance
impl Magic for Wizard{}  // 且只有 Wizard 得到 Magic

fn attack_with_bow&lt;T: FightFromDistance + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 10 {
        opponent.health -= 10;
        println!(
            &quot;You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}&quot;,
            opponent.health, character
        );
    }
}

fn attack_with_sword&lt;T: FightClose + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster) {
    opponent.health -= 10;
    println!(
        &quot;You attack with your sword. Your opponent now has {} health left. You are now at: {:?}&quot;,
        opponent.health, character
    );
}

fn fireball&lt;T: Magic + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 15 {
        opponent.health -= 20;
        println!(&quot;You raise your hands and cast a fireball! Your opponent now has {} health left. You are now at: {:?}&quot;,
    opponent.health, character);
    }
}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    attack_with_sword(&amp;radagast, &amp;mut uruk_hai);
    attack_with_bow(&amp;aragorn, &amp;mut uruk_hai, 8);
    fireball(&amp;radagast, &amp;mut uruk_hai, 8);
}</code></pre></pre>
<p>印出來的東西幾乎一樣：</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
You raise your hands and cast a fireball! Your opponent now has 0 health left. You are now at: Wizard { health: 60 }
</code></pre>
<p>所以你可以看到，當你使用特徵時，有很多方式可以做到同樣的事情。這一切都取決於什麼對你正在編寫的程式最有意義。</p>
<p>現在讓我們來看看如何實作一些你會在 Rust 中使用的主要特徵。</p>
<h3 id="from-特徵"><a class="header" href="#from-特徵">From 特徵</a></h3>
<p><em>From</em> 是個非常方便使用的特徵，你知道這一點是因為你已經看過很多遍。有了 <em>From</em> 你可以從 <code>&amp;str</code> 做出 <code>String</code>，但你也可以用許多其他型別做出許多種型別。例如，Vec 能用 <em>From</em> 在以下型別：</p>
<pre><code class="language-text">From&lt;&amp;'_ [T]&gt;
From&lt;&amp;'_ mut [T]&gt;
From&lt;&amp;'_ str&gt;
From&lt;&amp;'a Vec&lt;T&gt;&gt;
From&lt;[T; N]&gt;
From&lt;BinaryHeap&lt;T&gt;&gt;
From&lt;Box&lt;[T]&gt;&gt;
From&lt;CString&gt;
From&lt;Cow&lt;'a, [T]&gt;&gt;
From&lt;String&gt;
From&lt;Vec&lt;NonZeroU8&gt;&gt;
From&lt;Vec&lt;T&gt;&gt;
From&lt;VecDeque&lt;T&gt;&gt;
</code></pre>
<p>那裡還有很多種 <code>Vec::from()</code> 我們還沒有嘗試用過。我們來用幾個看看會怎麼樣。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display; // 我們會做個用來印出它們的泛型函式，所以我們想要 Display

fn print_vec&lt;T: Display&gt;(input: &amp;Vec&lt;T&gt;) { // 接受 Vec&lt;T&gt; 如果型別 T 有 Display
    for item in input {
        print!(&quot;{} &quot;, item);
    }
    println!();
}

fn main() {

    let array_vec = Vec::from([8, 9, 10]); // 試著對陣列 from
    print_vec(&amp;array_vec);

    let str_vec = Vec::from(&quot;What kind of vec will I be?&quot;); // 對 &amp;str from 的陣列？ 這會蠻有趣的
    print_vec(&amp;str_vec);

    let string_vec = Vec::from(&quot;What kind of vec will a String be?&quot;.to_string()); // 也是對 String 去 from
    print_vec(&amp;string_vec);
}</code></pre></pre>
<p>印出的內容如下：</p>
<pre><code class="language-text">8 9 10
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 73 32 98 101 63
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 97 32 83 116 114 105 110 103 32 98 101 63
</code></pre>
<p>如果你觀察型別，第二個和第三個向量都是 <code>Vec&lt;u8&gt;</code>，也就是 <code>&amp;str</code> 和 <code>String</code> 的位元組。所以你可以看到 <code>From</code> 是非常靈活的，且用得很多。讓我們用自己的型別來試試看。</p>
<p>我們將做兩個結構體，然後為其中一個結構體實作 <code>From</code>。一個結構體會是 <code>City</code>，另一個結構體則會是 <code>Country</code>。我們希望能夠做到這件事：<code>let country_name = Country::from(vector_of_cities)</code>。</p>
<p>它看起來像這樣：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // 這樣我們可以印出 City
struct City {
    name: String,
    population: u32,
}

impl City {
    fn new(name: &amp;str, population: u32) -&gt; Self { // 只是新的函式
        Self {
            name: name.to_string(),
            population,
        }
    }
}
#[derive(Debug)] // Country 也要可以被印出
struct Country {
    cities: Vec&lt;City&gt;, // 我們的城市都在這裡
}

impl From&lt;Vec&lt;City&gt;&gt; for Country { // 注意: 我們不用去寫 From&lt;City&gt;, 我們也可以改用
                                   // From&lt;Vec&lt;City&gt;&gt;. 因此我們也能實作在我們
                                   // 未曾建立的型別上
    fn from(cities: Vec&lt;City&gt;) -&gt; Self {
        Self { cities }
    }
}

impl Country {
    fn print_cities(&amp;self) { // 函式印出 Country 內的城市
        for city in &amp;self.cities {
            // 用 &amp; 因為 Vec&lt;City&gt; 不是 Copy
            println!(&quot;{:?} has a population of {:?}.&quot;, city.name, city.population);
        }
    }
}

fn main() {
    let helsinki = City::new(&quot;Helsinki&quot;, 631_695);
    let turku = City::new(&quot;Turku&quot;, 186_756);

    let finland_cities = vec![helsinki, turku]; // 這是 Vec&lt;City&gt;
    let finland = Country::from(finland_cities); // 所以現在我們能用 From

    finland.print_cities();
}</code></pre></pre>
<p>印出：</p>
<pre><code class="language-text">&quot;Helsinki&quot; has a population of 631695.
&quot;Turku&quot; has a population of 186756.
</code></pre>
<p>你可以看到，很容易從你沒有建立的型別中實作出 <code>From</code>，比如 <code>Vec</code>、<code>i32</code> 等等。這裡還有一個例子是，我們建立有兩個向量的向量。第一個向量存放偶數，第二個向量存放奇數。你可以用 <code>From</code> 給它一個 <code>i32</code> 的向量，它會把它變成 <code>Vec&lt;Vec&lt;i32&gt;&gt;</code>：一個向量裡面有許多容納 <code>i32</code> 的向量。</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::From;

struct EvenOddVec(Vec&lt;Vec&lt;i32&gt;&gt;);

impl From&lt;Vec&lt;i32&gt;&gt; for EvenOddVec {
    fn from(input: Vec&lt;i32&gt;) -&gt; Self {
        let mut even_odd_vec: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![], vec![]]; // 向量的裡面有兩個空向量
                                                                    // 這是回傳值但首先我們必須先將它填充
        for item in input {
            if item % 2 == 0 {
                even_odd_vec[0].push(item);
            } else {
                even_odd_vec[1].push(item);
            }
        }
        Self(even_odd_vec) // 現在它完成了那我們把它回傳為 Self (Self = EvenOddVec)
    }
}

fn main() {
    let bunch_of_numbers = vec![8, 7, -1, 3, 222, 9787, -47, 77, 0, 55, 7, 8];
    let new_vec = EvenOddVec::from(bunch_of_numbers);

    println!(&quot;Even numbers: {:?}\nOdd numbers: {:?}&quot;, new_vec.0[0], new_vec.0[1]);
}</code></pre></pre>
<p>印出：</p>
<pre><code class="language-text">Even numbers: [8, 222, 0, 8]
Odd numbers: [7, -1, 3, 9787, -47, 77, 55, 7]
</code></pre>
<p>像 <code>EvenOddVec</code> 這樣的型別可能最好是用泛型的 <code>T</code>，這樣我們就可以用在許多數值型別。如果你想練習的話，你可以試著把這個範例做成泛型的。</p>
<h3 id="接受-string-和-str-的函式"><a class="header" href="#接受-string-和-str-的函式">接受 String 和 &amp;str 的函式</a></h3>
<p>有時你想讓函式能同時接受 <code>String</code> 和 <code>&amp;str</code>。你可以透過泛型和 <code>AsRef</code> 特徵來做到這件事。<code>AsRef</code> 用於從某個型別向另一個型別提供參考。如果你查閱 <code>String</code> 文件，你可以看到它對許多型別都有提供 <code>AsRef</code>：</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>這些是它們的一些函式簽名。</p>
<p><code>AsRef&lt;str&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl AsRef&lt;str&gt; for String

fn as_ref(&amp;self) -&gt; &amp;str
<span class="boring">}</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl AsRef&lt;[u8]&gt; for String

fn as_ref(&amp;self) -&gt; &amp;[u8]
<span class="boring">}</span></code></pre></pre>
<p><code>AsRef&lt;OsStr&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl AsRef&lt;OsStr&gt; for String

fn as_ref(&amp;self) -&gt; &amp;OsStr
<span class="boring">}</span></code></pre></pre>
<p>你可以看到，它接受 <code>&amp;self</code>，並給出另一個型別的參考。這意味著，如果你有個泛型型別 T，你可以說它需要 <code>AsRef&lt;str&gt;</code>。如果你這樣做，它將會能夠接受 <code>&amp;str</code> 和 <code>String</code>。</p>
<p>讓我們先從泛型函式說起。這個還不能執行：</p>
<pre><pre class="playground"><code class="language-rust">fn print_it&lt;T&gt;(input: T) {
    println!(&quot;{}&quot;, input) // ⚠️
}

fn main() {
    print_it(&quot;Please print me&quot;);
}</code></pre></pre>
<p>Rust說 <code>error[E0277]: T doesn't implement std::fmt::Display</code>。所以我們會被要求給 T 實作 Display。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    print_it(&quot;Please print me&quot;);
}</code></pre></pre>
<p>現在可以執行並印出 <code>Please print me</code>。這不錯，但 T 仍然可以是太多種類的型別。它可以是 <code>i8</code>、<code>f32</code> 及任何其它有 <code>Display</code> 的東西。所以我們加上 <code>AsRef&lt;str&gt;</code>，那麼現在 T 需要同時有實作 <code>AsRef&lt;str&gt;</code> 和 <code>Display</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: AsRef&lt;str&gt; + Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    print_it(&quot;Please print me&quot;);
    print_it(&quot;Also, please print me&quot;.to_string());
    // print_it(7); &lt;- 這不會印出來
}</code></pre></pre>
<p>現在它不會接受像 <code>i8</code> 這樣的型別。</p>
<p>不要忘了，你可以在函式變長時用 <code>where</code> 以不一樣的方式寫出函式。如果我們加上 Debug，那麼它就會變成一整行長長的 <code>fn print_it&lt;T: AsRef&lt;str&gt; + Display + Debug&gt;(input: T)</code>。因此我們可以寫成這樣：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::{Debug, Display}; // 加上 Debug

fn print_it&lt;T&gt;(input: T) // 現在這行好讀多了
where
    T: AsRef&lt;str&gt; + Debug + Display, // 並且這些特徵也好讀
{
    println!(&quot;{}&quot;, input)
}

fn main() {
    print_it(&quot;Please print me&quot;);
    print_it(&quot;Also, please print me&quot;.to_string());
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Chapter_33.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="Chapter_35.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Chapter_33.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="Chapter_35.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
